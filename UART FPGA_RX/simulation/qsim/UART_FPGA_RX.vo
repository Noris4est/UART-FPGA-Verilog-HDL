// Copyright (C) 2018  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details.

// VENDOR "Altera"
// PROGRAM "Quartus Prime"
// VERSION "Version 18.1.0 Build 625 09/12/2018 SJ Lite Edition"

// DATE "04/09/2020 00:26:54"

// 
// Device: Altera EPM240T100C5 Package TQFP100
// 

// 
// This Verilog file should be used for ModelSim-Altera (Verilog) only
// 

`timescale 1 ps/ 1 ps

module UART_FPGA_RX (
	IN_CLOCK,
	IN_RX_SERIAL,
	OUT_RX_DATA_READY,
	OUT_RX_DATA,
	OUT_RX_ERROR);
input 	IN_CLOCK;
input 	IN_RX_SERIAL;
output 	OUT_RX_DATA_READY;
output 	[7:0] OUT_RX_DATA;
output 	OUT_RX_ERROR;

// Design Ports Information


wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

tri1 devclrn;
tri1 devpor;
tri1 devoe;
wire \IN_CLOCK~combout ;
wire \Add1~0_combout ;
wire \IN_RX_SERIAL~combout ;
wire \LessThan2~1_combout ;
wire \Equal0~0_combout ;
wire \LessThan2~0_combout ;
wire \Selector3~1_combout ;
wire \Selector3~2_combout ;
wire \REG_STATE.STATE_RX_START_BIT~regout ;
wire \REG_CLOCK_COUNT[1]~0_combout ;
wire \Selector2~0_combout ;
wire \Selector4~2_combout ;
wire \REG_STATE.STATE_WAIT~regout ;
wire \Selector4~4_combout ;
wire \REG_STATE.STATE_RX_DATA_BITS~regout ;
wire \Decoder0~2_combout ;
wire \Selector6~0_combout ;
wire \REG_STATE.STATE_RX_PARITY_BIT~regout ;
wire \REG_STATE.STATE_RX_STOP_BIT~regout ;
wire \Selector1~0_combout ;
wire \REG_STATE.STATE_RX_STOP_BIT~0_combout ;
wire \Selector1~1_combout ;
wire \Decoder0~6_combout ;
wire \Decoder0~0_combout ;
wire \OUT_RX_DATA[4]~reg0_regout ;
wire \Decoder0~7_combout ;
wire \OUT_RX_DATA[7]~reg0_regout ;
wire \Decoder0~3_combout ;
wire \OUT_RX_DATA[5]~reg0_regout ;
wire \Decoder0~8_combout ;
wire \OUT_RX_DATA[6]~reg0_regout ;
wire \Add9~1_combout ;
wire \Decoder0~4_combout ;
wire \OUT_RX_DATA[2]~reg0_regout ;
wire \Decoder0~5_combout ;
wire \OUT_RX_DATA[3]~reg0_regout ;
wire \Decoder0~1_combout ;
wire \OUT_RX_DATA[0]~reg0_regout ;
wire \OUT_RX_DATA[1]~reg0_regout ;
wire \Add9~0_combout ;
wire \Add9~2_combout ;
wire \OUT_RX_ERROR~reg0_regout ;
wire \Selector0~0_combout ;
wire \OUT_RX_DATA_READY~reg0_regout ;
wire [2:0] REG_CLOCK_COUNT;
wire [3:0] REG_BIT_INDEX;


// Location: PIN_14,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \IN_CLOCK~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\IN_CLOCK~combout ),
	.padio(IN_CLOCK));
// synopsys translate_off
defparam \IN_CLOCK~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X5_Y3_N4
maxii_lcell \Add1~0 (
// Equation(s):
// \Add1~0_combout  = (((REG_BIT_INDEX[1] & REG_BIT_INDEX[0])))

	.clk(gnd),
	.dataa(vcc),
	.datab(vcc),
	.datac(REG_BIT_INDEX[1]),
	.datad(REG_BIT_INDEX[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Add1~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Add1~0 .lut_mask = "f000";
defparam \Add1~0 .operation_mode = "normal";
defparam \Add1~0 .output_mode = "comb_only";
defparam \Add1~0 .register_cascade_mode = "off";
defparam \Add1~0 .sum_lutc_input = "datac";
defparam \Add1~0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_8,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \IN_RX_SERIAL~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\IN_RX_SERIAL~combout ),
	.padio(IN_RX_SERIAL));
// synopsys translate_off
defparam \IN_RX_SERIAL~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X4_Y3_N7
maxii_lcell \LessThan2~1 (
// Equation(s):
// \LessThan2~1_combout  = (((!REG_CLOCK_COUNT[1]) # (!REG_CLOCK_COUNT[0])))

	.clk(gnd),
	.dataa(vcc),
	.datab(vcc),
	.datac(REG_CLOCK_COUNT[0]),
	.datad(REG_CLOCK_COUNT[1]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\LessThan2~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \LessThan2~1 .lut_mask = "0fff";
defparam \LessThan2~1 .operation_mode = "normal";
defparam \LessThan2~1 .output_mode = "comb_only";
defparam \LessThan2~1 .register_cascade_mode = "off";
defparam \LessThan2~1 .sum_lutc_input = "datac";
defparam \LessThan2~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N9
maxii_lcell \REG_CLOCK_COUNT[2] (
// Equation(s):
// REG_CLOCK_COUNT[2] = DFFEAS((\REG_STATE.STATE_WAIT~regout  & (\REG_CLOCK_COUNT[1]~0_combout  & (REG_CLOCK_COUNT[2] $ (!\LessThan2~1_combout )))) # (!\REG_STATE.STATE_WAIT~regout  & (REG_CLOCK_COUNT[2])), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\REG_STATE.STATE_WAIT~regout ),
	.datab(REG_CLOCK_COUNT[2]),
	.datac(\LessThan2~1_combout ),
	.datad(\REG_CLOCK_COUNT[1]~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(REG_CLOCK_COUNT[2]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_CLOCK_COUNT[2] .lut_mask = "c644";
defparam \REG_CLOCK_COUNT[2] .operation_mode = "normal";
defparam \REG_CLOCK_COUNT[2] .output_mode = "reg_only";
defparam \REG_CLOCK_COUNT[2] .register_cascade_mode = "off";
defparam \REG_CLOCK_COUNT[2] .sum_lutc_input = "datac";
defparam \REG_CLOCK_COUNT[2] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N6
maxii_lcell \Equal0~0 (
// Equation(s):
// \Equal0~0_combout  = ((REG_CLOCK_COUNT[2]) # ((REG_CLOCK_COUNT[0]) # (REG_CLOCK_COUNT[1])))

	.clk(gnd),
	.dataa(vcc),
	.datab(REG_CLOCK_COUNT[2]),
	.datac(REG_CLOCK_COUNT[0]),
	.datad(REG_CLOCK_COUNT[1]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Equal0~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Equal0~0 .lut_mask = "fffc";
defparam \Equal0~0 .operation_mode = "normal";
defparam \Equal0~0 .output_mode = "comb_only";
defparam \Equal0~0 .register_cascade_mode = "off";
defparam \Equal0~0 .sum_lutc_input = "datac";
defparam \Equal0~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N2
maxii_lcell \LessThan2~0 (
// Equation(s):
// \LessThan2~0_combout  = ((!REG_CLOCK_COUNT[2] & ((!REG_CLOCK_COUNT[1]) # (!REG_CLOCK_COUNT[0]))))

	.clk(gnd),
	.dataa(REG_CLOCK_COUNT[0]),
	.datab(vcc),
	.datac(REG_CLOCK_COUNT[1]),
	.datad(REG_CLOCK_COUNT[2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\LessThan2~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \LessThan2~0 .lut_mask = "005f";
defparam \LessThan2~0 .operation_mode = "normal";
defparam \LessThan2~0 .output_mode = "comb_only";
defparam \LessThan2~0 .register_cascade_mode = "off";
defparam \LessThan2~0 .sum_lutc_input = "datac";
defparam \LessThan2~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N5
maxii_lcell \Selector3~1 (
// Equation(s):
// \Selector3~1_combout  = (\REG_STATE.STATE_RX_START_BIT~regout  & ((\LessThan2~0_combout ) # ((!\REG_STATE.STATE_RX_STOP_BIT~regout  & !\REG_STATE.STATE_RX_PARITY_BIT~regout ))))

	.clk(gnd),
	.dataa(\REG_STATE.STATE_RX_START_BIT~regout ),
	.datab(\REG_STATE.STATE_RX_STOP_BIT~regout ),
	.datac(\LessThan2~0_combout ),
	.datad(\REG_STATE.STATE_RX_PARITY_BIT~regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector3~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector3~1 .lut_mask = "a0a2";
defparam \Selector3~1 .operation_mode = "normal";
defparam \Selector3~1 .output_mode = "comb_only";
defparam \Selector3~1 .register_cascade_mode = "off";
defparam \Selector3~1 .sum_lutc_input = "datac";
defparam \Selector3~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N6
maxii_lcell \Selector3~2 (
// Equation(s):
// \Selector3~2_combout  = (\IN_RX_SERIAL~combout  & (((!\Selector3~1_combout ) # (!\Equal0~0_combout )))) # (!\IN_RX_SERIAL~combout  & (\REG_STATE.STATE_WAIT~regout  & ((!\Selector3~1_combout ) # (!\Equal0~0_combout ))))

	.clk(gnd),
	.dataa(\IN_RX_SERIAL~combout ),
	.datab(\REG_STATE.STATE_WAIT~regout ),
	.datac(\Equal0~0_combout ),
	.datad(\Selector3~1_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector3~2_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector3~2 .lut_mask = "0eee";
defparam \Selector3~2 .operation_mode = "normal";
defparam \Selector3~2 .output_mode = "comb_only";
defparam \Selector3~2 .register_cascade_mode = "off";
defparam \Selector3~2 .sum_lutc_input = "datac";
defparam \Selector3~2 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N7
maxii_lcell \REG_STATE.STATE_RX_START_BIT (
// Equation(s):
// \REG_STATE.STATE_RX_START_BIT~regout  = DFFEAS((!\Selector3~2_combout  & (((!\Decoder0~2_combout ) # (!\Add1~0_combout )) # (!REG_BIT_INDEX[2]))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(REG_BIT_INDEX[2]),
	.datab(\Add1~0_combout ),
	.datac(\Decoder0~2_combout ),
	.datad(\Selector3~2_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\REG_STATE.STATE_RX_START_BIT~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_STATE.STATE_RX_START_BIT .lut_mask = "007f";
defparam \REG_STATE.STATE_RX_START_BIT .operation_mode = "normal";
defparam \REG_STATE.STATE_RX_START_BIT .output_mode = "reg_only";
defparam \REG_STATE.STATE_RX_START_BIT .register_cascade_mode = "off";
defparam \REG_STATE.STATE_RX_START_BIT .sum_lutc_input = "datac";
defparam \REG_STATE.STATE_RX_START_BIT .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N3
maxii_lcell \REG_CLOCK_COUNT[1]~0 (
// Equation(s):
// \REG_CLOCK_COUNT[1]~0_combout  = ((\REG_STATE.STATE_RX_START_BIT~regout  & (\Equal0~0_combout )) # (!\REG_STATE.STATE_RX_START_BIT~regout  & ((\LessThan2~0_combout ))))

	.clk(gnd),
	.dataa(vcc),
	.datab(\REG_STATE.STATE_RX_START_BIT~regout ),
	.datac(\Equal0~0_combout ),
	.datad(\LessThan2~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\REG_CLOCK_COUNT[1]~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_CLOCK_COUNT[1]~0 .lut_mask = "f3c0";
defparam \REG_CLOCK_COUNT[1]~0 .operation_mode = "normal";
defparam \REG_CLOCK_COUNT[1]~0 .output_mode = "comb_only";
defparam \REG_CLOCK_COUNT[1]~0 .register_cascade_mode = "off";
defparam \REG_CLOCK_COUNT[1]~0 .sum_lutc_input = "datac";
defparam \REG_CLOCK_COUNT[1]~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N4
maxii_lcell \REG_CLOCK_COUNT[1] (
// Equation(s):
// REG_CLOCK_COUNT[1] = DFFEAS((\REG_STATE.STATE_WAIT~regout  & (\REG_CLOCK_COUNT[1]~0_combout  & (REG_CLOCK_COUNT[1] $ (REG_CLOCK_COUNT[0])))) # (!\REG_STATE.STATE_WAIT~regout  & (REG_CLOCK_COUNT[1])), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\REG_STATE.STATE_WAIT~regout ),
	.datab(REG_CLOCK_COUNT[1]),
	.datac(REG_CLOCK_COUNT[0]),
	.datad(\REG_CLOCK_COUNT[1]~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(REG_CLOCK_COUNT[1]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_CLOCK_COUNT[1] .lut_mask = "6c44";
defparam \REG_CLOCK_COUNT[1] .operation_mode = "normal";
defparam \REG_CLOCK_COUNT[1] .output_mode = "reg_only";
defparam \REG_CLOCK_COUNT[1] .register_cascade_mode = "off";
defparam \REG_CLOCK_COUNT[1] .sum_lutc_input = "datac";
defparam \REG_CLOCK_COUNT[1] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N8
maxii_lcell \Selector2~0 (
// Equation(s):
// \Selector2~0_combout  = (\REG_STATE.STATE_RX_STOP_BIT~regout  & ((REG_CLOCK_COUNT[2]) # ((REG_CLOCK_COUNT[1] & REG_CLOCK_COUNT[0]))))

	.clk(gnd),
	.dataa(\REG_STATE.STATE_RX_STOP_BIT~regout ),
	.datab(REG_CLOCK_COUNT[1]),
	.datac(REG_CLOCK_COUNT[2]),
	.datad(REG_CLOCK_COUNT[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector2~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector2~0 .lut_mask = "a8a0";
defparam \Selector2~0 .operation_mode = "normal";
defparam \Selector2~0 .output_mode = "comb_only";
defparam \Selector2~0 .register_cascade_mode = "off";
defparam \Selector2~0 .sum_lutc_input = "datac";
defparam \Selector2~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N1
maxii_lcell \Selector4~2 (
// Equation(s):
// \Selector4~2_combout  = (!REG_CLOCK_COUNT[0] & (!REG_CLOCK_COUNT[1] & (!REG_CLOCK_COUNT[2] & \REG_STATE.STATE_RX_START_BIT~regout )))

	.clk(gnd),
	.dataa(REG_CLOCK_COUNT[0]),
	.datab(REG_CLOCK_COUNT[1]),
	.datac(REG_CLOCK_COUNT[2]),
	.datad(\REG_STATE.STATE_RX_START_BIT~regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector4~2_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector4~2 .lut_mask = "0100";
defparam \Selector4~2 .operation_mode = "normal";
defparam \Selector4~2 .output_mode = "comb_only";
defparam \Selector4~2 .register_cascade_mode = "off";
defparam \Selector4~2 .sum_lutc_input = "datac";
defparam \Selector4~2 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N9
maxii_lcell \REG_STATE.STATE_WAIT (
// Equation(s):
// \REG_STATE.STATE_WAIT~regout  = DFFEAS((!\Selector2~0_combout  & (((\REG_STATE.STATE_WAIT~regout  & !\Selector4~2_combout )) # (!\IN_RX_SERIAL~combout ))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\Selector2~0_combout ),
	.datab(\REG_STATE.STATE_WAIT~regout ),
	.datac(\IN_RX_SERIAL~combout ),
	.datad(\Selector4~2_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\REG_STATE.STATE_WAIT~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_STATE.STATE_WAIT .lut_mask = "0545";
defparam \REG_STATE.STATE_WAIT .operation_mode = "normal";
defparam \REG_STATE.STATE_WAIT .output_mode = "reg_only";
defparam \REG_STATE.STATE_WAIT .register_cascade_mode = "off";
defparam \REG_STATE.STATE_WAIT .sum_lutc_input = "datac";
defparam \REG_STATE.STATE_WAIT .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N5
maxii_lcell \REG_CLOCK_COUNT[0] (
// Equation(s):
// REG_CLOCK_COUNT[0] = DFFEAS((\REG_STATE.STATE_WAIT~regout  & (((!REG_CLOCK_COUNT[0] & \REG_CLOCK_COUNT[1]~0_combout )))) # (!\REG_STATE.STATE_WAIT~regout  & (((REG_CLOCK_COUNT[0])))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\REG_STATE.STATE_WAIT~regout ),
	.datab(vcc),
	.datac(REG_CLOCK_COUNT[0]),
	.datad(\REG_CLOCK_COUNT[1]~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(REG_CLOCK_COUNT[0]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_CLOCK_COUNT[0] .lut_mask = "5a50";
defparam \REG_CLOCK_COUNT[0] .operation_mode = "normal";
defparam \REG_CLOCK_COUNT[0] .output_mode = "reg_only";
defparam \REG_CLOCK_COUNT[0] .register_cascade_mode = "off";
defparam \REG_CLOCK_COUNT[0] .sum_lutc_input = "datac";
defparam \REG_CLOCK_COUNT[0] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N1
maxii_lcell \Selector4~4 (
// Equation(s):
// \Selector4~4_combout  = (REG_BIT_INDEX[1] & (REG_BIT_INDEX[2] & (REG_BIT_INDEX[0] & !\LessThan2~0_combout )))

	.clk(gnd),
	.dataa(REG_BIT_INDEX[1]),
	.datab(REG_BIT_INDEX[2]),
	.datac(REG_BIT_INDEX[0]),
	.datad(\LessThan2~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector4~4_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector4~4 .lut_mask = "0080";
defparam \Selector4~4 .operation_mode = "normal";
defparam \Selector4~4 .output_mode = "comb_only";
defparam \Selector4~4 .register_cascade_mode = "off";
defparam \Selector4~4 .sum_lutc_input = "datac";
defparam \Selector4~4 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N9
maxii_lcell \REG_STATE.STATE_RX_DATA_BITS (
// Equation(s):
// \REG_STATE.STATE_RX_DATA_BITS~regout  = DFFEAS((\IN_RX_SERIAL~combout  & (\REG_STATE.STATE_RX_DATA_BITS~regout  & ((!\Selector4~4_combout )))) # (!\IN_RX_SERIAL~combout  & ((\Selector4~2_combout ) # ((\REG_STATE.STATE_RX_DATA_BITS~regout  & 
// !\Selector4~4_combout )))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\IN_RX_SERIAL~combout ),
	.datab(\REG_STATE.STATE_RX_DATA_BITS~regout ),
	.datac(\Selector4~2_combout ),
	.datad(\Selector4~4_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\REG_STATE.STATE_RX_DATA_BITS~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_STATE.STATE_RX_DATA_BITS .lut_mask = "50dc";
defparam \REG_STATE.STATE_RX_DATA_BITS .operation_mode = "normal";
defparam \REG_STATE.STATE_RX_DATA_BITS .output_mode = "reg_only";
defparam \REG_STATE.STATE_RX_DATA_BITS .register_cascade_mode = "off";
defparam \REG_STATE.STATE_RX_DATA_BITS .sum_lutc_input = "datac";
defparam \REG_STATE.STATE_RX_DATA_BITS .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N5
maxii_lcell \Decoder0~2 (
// Equation(s):
// \Decoder0~2_combout  = (\REG_STATE.STATE_RX_DATA_BITS~regout  & ((REG_CLOCK_COUNT[2]) # ((REG_CLOCK_COUNT[0] & REG_CLOCK_COUNT[1]))))

	.clk(gnd),
	.dataa(REG_CLOCK_COUNT[0]),
	.datab(\REG_STATE.STATE_RX_DATA_BITS~regout ),
	.datac(REG_CLOCK_COUNT[2]),
	.datad(REG_CLOCK_COUNT[1]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~2_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~2 .lut_mask = "c8c0";
defparam \Decoder0~2 .operation_mode = "normal";
defparam \Decoder0~2 .output_mode = "comb_only";
defparam \Decoder0~2 .register_cascade_mode = "off";
defparam \Decoder0~2 .sum_lutc_input = "datac";
defparam \Decoder0~2 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N8
maxii_lcell \REG_BIT_INDEX[0] (
// Equation(s):
// REG_BIT_INDEX[0] = DFFEAS((((!REG_BIT_INDEX[0]))), GLOBAL(\IN_CLOCK~combout ), VCC, , \Decoder0~2_combout , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(REG_BIT_INDEX[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(REG_BIT_INDEX[0]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_BIT_INDEX[0] .lut_mask = "00ff";
defparam \REG_BIT_INDEX[0] .operation_mode = "normal";
defparam \REG_BIT_INDEX[0] .output_mode = "reg_only";
defparam \REG_BIT_INDEX[0] .register_cascade_mode = "off";
defparam \REG_BIT_INDEX[0] .sum_lutc_input = "datac";
defparam \REG_BIT_INDEX[0] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N6
maxii_lcell \REG_BIT_INDEX[1] (
// Equation(s):
// REG_BIT_INDEX[1] = DFFEAS(REG_BIT_INDEX[0] $ ((((REG_BIT_INDEX[1])))), GLOBAL(\IN_CLOCK~combout ), VCC, , \Decoder0~2_combout , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(REG_BIT_INDEX[0]),
	.datab(vcc),
	.datac(REG_BIT_INDEX[1]),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(REG_BIT_INDEX[1]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_BIT_INDEX[1] .lut_mask = "5a5a";
defparam \REG_BIT_INDEX[1] .operation_mode = "normal";
defparam \REG_BIT_INDEX[1] .output_mode = "reg_only";
defparam \REG_BIT_INDEX[1] .register_cascade_mode = "off";
defparam \REG_BIT_INDEX[1] .sum_lutc_input = "datac";
defparam \REG_BIT_INDEX[1] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N0
maxii_lcell \REG_BIT_INDEX[2] (
// Equation(s):
// REG_BIT_INDEX[2] = DFFEAS((REG_BIT_INDEX[2] $ (((REG_BIT_INDEX[1] & REG_BIT_INDEX[0])))), GLOBAL(\IN_CLOCK~combout ), VCC, , \Decoder0~2_combout , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(REG_BIT_INDEX[1]),
	.datab(vcc),
	.datac(REG_BIT_INDEX[2]),
	.datad(REG_BIT_INDEX[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(REG_BIT_INDEX[2]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_BIT_INDEX[2] .lut_mask = "5af0";
defparam \REG_BIT_INDEX[2] .operation_mode = "normal";
defparam \REG_BIT_INDEX[2] .output_mode = "reg_only";
defparam \REG_BIT_INDEX[2] .register_cascade_mode = "off";
defparam \REG_BIT_INDEX[2] .sum_lutc_input = "datac";
defparam \REG_BIT_INDEX[2] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N0
maxii_lcell \Selector6~0 (
// Equation(s):
// \Selector6~0_combout  = (\REG_STATE.STATE_RX_PARITY_BIT~regout  & (!REG_CLOCK_COUNT[2] & ((!REG_CLOCK_COUNT[0]) # (!REG_CLOCK_COUNT[1]))))

	.clk(gnd),
	.dataa(\REG_STATE.STATE_RX_PARITY_BIT~regout ),
	.datab(REG_CLOCK_COUNT[1]),
	.datac(REG_CLOCK_COUNT[2]),
	.datad(REG_CLOCK_COUNT[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector6~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector6~0 .lut_mask = "020a";
defparam \Selector6~0 .operation_mode = "normal";
defparam \Selector6~0 .output_mode = "comb_only";
defparam \Selector6~0 .register_cascade_mode = "off";
defparam \Selector6~0 .sum_lutc_input = "datac";
defparam \Selector6~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N4
maxii_lcell \REG_STATE.STATE_RX_PARITY_BIT (
// Equation(s):
// \REG_STATE.STATE_RX_PARITY_BIT~regout  = DFFEAS((\Selector6~0_combout ) # ((REG_BIT_INDEX[2] & (\Decoder0~2_combout  & \Add1~0_combout ))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(REG_BIT_INDEX[2]),
	.datab(\Selector6~0_combout ),
	.datac(\Decoder0~2_combout ),
	.datad(\Add1~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\REG_STATE.STATE_RX_PARITY_BIT~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_STATE.STATE_RX_PARITY_BIT .lut_mask = "eccc";
defparam \REG_STATE.STATE_RX_PARITY_BIT .operation_mode = "normal";
defparam \REG_STATE.STATE_RX_PARITY_BIT .output_mode = "reg_only";
defparam \REG_STATE.STATE_RX_PARITY_BIT .register_cascade_mode = "off";
defparam \REG_STATE.STATE_RX_PARITY_BIT .sum_lutc_input = "datac";
defparam \REG_STATE.STATE_RX_PARITY_BIT .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N3
maxii_lcell \REG_STATE.STATE_RX_STOP_BIT (
// Equation(s):
// \REG_STATE.STATE_RX_STOP_BIT~regout  = DFFEAS(((\LessThan2~0_combout  & ((\REG_STATE.STATE_RX_STOP_BIT~regout ))) # (!\LessThan2~0_combout  & (\REG_STATE.STATE_RX_PARITY_BIT~regout ))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\REG_STATE.STATE_RX_PARITY_BIT~regout ),
	.datab(vcc),
	.datac(\LessThan2~0_combout ),
	.datad(\REG_STATE.STATE_RX_STOP_BIT~regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\REG_STATE.STATE_RX_STOP_BIT~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_STATE.STATE_RX_STOP_BIT .lut_mask = "fa0a";
defparam \REG_STATE.STATE_RX_STOP_BIT .operation_mode = "normal";
defparam \REG_STATE.STATE_RX_STOP_BIT .output_mode = "reg_only";
defparam \REG_STATE.STATE_RX_STOP_BIT .register_cascade_mode = "off";
defparam \REG_STATE.STATE_RX_STOP_BIT .sum_lutc_input = "datac";
defparam \REG_STATE.STATE_RX_STOP_BIT .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N6
maxii_lcell \Selector1~0 (
// Equation(s):
// \Selector1~0_combout  = (\OUT_RX_ERROR~reg0_regout  & ((\REG_STATE.STATE_RX_STOP_BIT~regout ) # ((\REG_STATE.STATE_RX_DATA_BITS~regout ) # (\REG_STATE.STATE_RX_START_BIT~regout ))))

	.clk(gnd),
	.dataa(\REG_STATE.STATE_RX_STOP_BIT~regout ),
	.datab(\REG_STATE.STATE_RX_DATA_BITS~regout ),
	.datac(\OUT_RX_ERROR~reg0_regout ),
	.datad(\REG_STATE.STATE_RX_START_BIT~regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector1~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector1~0 .lut_mask = "f0e0";
defparam \Selector1~0 .operation_mode = "normal";
defparam \Selector1~0 .output_mode = "comb_only";
defparam \Selector1~0 .register_cascade_mode = "off";
defparam \Selector1~0 .sum_lutc_input = "datac";
defparam \Selector1~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N2
maxii_lcell \REG_STATE.STATE_RX_STOP_BIT~0 (
// Equation(s):
// \REG_STATE.STATE_RX_STOP_BIT~0_combout  = (\REG_STATE.STATE_RX_PARITY_BIT~regout  & ((REG_CLOCK_COUNT[2]) # ((REG_CLOCK_COUNT[1] & REG_CLOCK_COUNT[0]))))

	.clk(gnd),
	.dataa(\REG_STATE.STATE_RX_PARITY_BIT~regout ),
	.datab(REG_CLOCK_COUNT[1]),
	.datac(REG_CLOCK_COUNT[2]),
	.datad(REG_CLOCK_COUNT[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\REG_STATE.STATE_RX_STOP_BIT~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \REG_STATE.STATE_RX_STOP_BIT~0 .lut_mask = "a8a0";
defparam \REG_STATE.STATE_RX_STOP_BIT~0 .operation_mode = "normal";
defparam \REG_STATE.STATE_RX_STOP_BIT~0 .output_mode = "comb_only";
defparam \REG_STATE.STATE_RX_STOP_BIT~0 .register_cascade_mode = "off";
defparam \REG_STATE.STATE_RX_STOP_BIT~0 .sum_lutc_input = "datac";
defparam \REG_STATE.STATE_RX_STOP_BIT~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N0
maxii_lcell \Selector1~1 (
// Equation(s):
// \Selector1~1_combout  = (\OUT_RX_ERROR~reg0_regout  & ((\Selector6~0_combout ) # ((!\IN_RX_SERIAL~combout  & \Selector2~0_combout )))) # (!\OUT_RX_ERROR~reg0_regout  & (!\IN_RX_SERIAL~combout  & ((\Selector2~0_combout ))))

	.clk(gnd),
	.dataa(\OUT_RX_ERROR~reg0_regout ),
	.datab(\IN_RX_SERIAL~combout ),
	.datac(\Selector6~0_combout ),
	.datad(\Selector2~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector1~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector1~1 .lut_mask = "b3a0";
defparam \Selector1~1 .operation_mode = "normal";
defparam \Selector1~1 .output_mode = "comb_only";
defparam \Selector1~1 .register_cascade_mode = "off";
defparam \Selector1~1 .sum_lutc_input = "datac";
defparam \Selector1~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N5
maxii_lcell \Decoder0~6 (
// Equation(s):
// \Decoder0~6_combout  = (((!REG_BIT_INDEX[0] & REG_BIT_INDEX[2])))

	.clk(gnd),
	.dataa(vcc),
	.datab(vcc),
	.datac(REG_BIT_INDEX[0]),
	.datad(REG_BIT_INDEX[2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~6_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~6 .lut_mask = "0f00";
defparam \Decoder0~6 .operation_mode = "normal";
defparam \Decoder0~6 .output_mode = "comb_only";
defparam \Decoder0~6 .register_cascade_mode = "off";
defparam \Decoder0~6 .sum_lutc_input = "datac";
defparam \Decoder0~6 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N3
maxii_lcell \Decoder0~0 (
// Equation(s):
// \Decoder0~0_combout  = ((\REG_STATE.STATE_RX_DATA_BITS~regout  & (!REG_BIT_INDEX[1] & !\LessThan2~0_combout )))

	.clk(gnd),
	.dataa(vcc),
	.datab(\REG_STATE.STATE_RX_DATA_BITS~regout ),
	.datac(REG_BIT_INDEX[1]),
	.datad(\LessThan2~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~0 .lut_mask = "000c";
defparam \Decoder0~0 .operation_mode = "normal";
defparam \Decoder0~0 .output_mode = "comb_only";
defparam \Decoder0~0 .register_cascade_mode = "off";
defparam \Decoder0~0 .sum_lutc_input = "datac";
defparam \Decoder0~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N4
maxii_lcell \OUT_RX_DATA[4]~reg0 (
// Equation(s):
// \OUT_RX_DATA[4]~reg0_regout  = DFFEAS((\Decoder0~6_combout  & ((\Decoder0~0_combout  & ((\IN_RX_SERIAL~combout ))) # (!\Decoder0~0_combout  & (\OUT_RX_DATA[4]~reg0_regout )))) # (!\Decoder0~6_combout  & (\OUT_RX_DATA[4]~reg0_regout )), 
// GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\OUT_RX_DATA[4]~reg0_regout ),
	.datab(\IN_RX_SERIAL~combout ),
	.datac(\Decoder0~6_combout ),
	.datad(\Decoder0~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[4]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[4]~reg0 .lut_mask = "caaa";
defparam \OUT_RX_DATA[4]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[4]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[4]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[4]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[4]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N8
maxii_lcell \Decoder0~7 (
// Equation(s):
// \Decoder0~7_combout  = (REG_BIT_INDEX[2] & (((\Decoder0~2_combout ))))

	.clk(gnd),
	.dataa(REG_BIT_INDEX[2]),
	.datab(vcc),
	.datac(vcc),
	.datad(\Decoder0~2_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~7_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~7 .lut_mask = "aa00";
defparam \Decoder0~7 .operation_mode = "normal";
defparam \Decoder0~7 .output_mode = "comb_only";
defparam \Decoder0~7 .register_cascade_mode = "off";
defparam \Decoder0~7 .sum_lutc_input = "datac";
defparam \Decoder0~7 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N7
maxii_lcell \OUT_RX_DATA[7]~reg0 (
// Equation(s):
// \OUT_RX_DATA[7]~reg0_regout  = DFFEAS((\Add1~0_combout  & ((\Decoder0~7_combout  & ((\IN_RX_SERIAL~combout ))) # (!\Decoder0~7_combout  & (\OUT_RX_DATA[7]~reg0_regout )))) # (!\Add1~0_combout  & (\OUT_RX_DATA[7]~reg0_regout )), GLOBAL(\IN_CLOCK~combout ), 
// VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\OUT_RX_DATA[7]~reg0_regout ),
	.datab(\IN_RX_SERIAL~combout ),
	.datac(\Add1~0_combout ),
	.datad(\Decoder0~7_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[7]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[7]~reg0 .lut_mask = "caaa";
defparam \OUT_RX_DATA[7]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[7]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[7]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[7]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[7]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N1
maxii_lcell \Decoder0~3 (
// Equation(s):
// \Decoder0~3_combout  = (REG_BIT_INDEX[0] & (!REG_BIT_INDEX[1] & ((\Decoder0~2_combout ))))

	.clk(gnd),
	.dataa(REG_BIT_INDEX[0]),
	.datab(REG_BIT_INDEX[1]),
	.datac(vcc),
	.datad(\Decoder0~2_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~3_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~3 .lut_mask = "2200";
defparam \Decoder0~3 .operation_mode = "normal";
defparam \Decoder0~3 .output_mode = "comb_only";
defparam \Decoder0~3 .register_cascade_mode = "off";
defparam \Decoder0~3 .sum_lutc_input = "datac";
defparam \Decoder0~3 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N6
maxii_lcell \OUT_RX_DATA[5]~reg0 (
// Equation(s):
// \OUT_RX_DATA[5]~reg0_regout  = DFFEAS((REG_BIT_INDEX[2] & ((\Decoder0~3_combout  & ((\IN_RX_SERIAL~combout ))) # (!\Decoder0~3_combout  & (\OUT_RX_DATA[5]~reg0_regout )))) # (!REG_BIT_INDEX[2] & (\OUT_RX_DATA[5]~reg0_regout )), GLOBAL(\IN_CLOCK~combout ), 
// VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\OUT_RX_DATA[5]~reg0_regout ),
	.datab(REG_BIT_INDEX[2]),
	.datac(\IN_RX_SERIAL~combout ),
	.datad(\Decoder0~3_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[5]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[5]~reg0 .lut_mask = "e2aa";
defparam \OUT_RX_DATA[5]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[5]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[5]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[5]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[5]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N0
maxii_lcell \Decoder0~8 (
// Equation(s):
// \Decoder0~8_combout  = (((!REG_BIT_INDEX[0] & REG_BIT_INDEX[1])))

	.clk(gnd),
	.dataa(vcc),
	.datab(vcc),
	.datac(REG_BIT_INDEX[0]),
	.datad(REG_BIT_INDEX[1]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~8_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~8 .lut_mask = "0f00";
defparam \Decoder0~8 .operation_mode = "normal";
defparam \Decoder0~8 .output_mode = "comb_only";
defparam \Decoder0~8 .register_cascade_mode = "off";
defparam \Decoder0~8 .sum_lutc_input = "datac";
defparam \Decoder0~8 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N9
maxii_lcell \OUT_RX_DATA[6]~reg0 (
// Equation(s):
// \OUT_RX_DATA[6]~reg0_regout  = DFFEAS((\Decoder0~8_combout  & ((\Decoder0~7_combout  & ((\IN_RX_SERIAL~combout ))) # (!\Decoder0~7_combout  & (\OUT_RX_DATA[6]~reg0_regout )))) # (!\Decoder0~8_combout  & (\OUT_RX_DATA[6]~reg0_regout )), 
// GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\OUT_RX_DATA[6]~reg0_regout ),
	.datab(\IN_RX_SERIAL~combout ),
	.datac(\Decoder0~8_combout ),
	.datad(\Decoder0~7_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[6]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[6]~reg0 .lut_mask = "caaa";
defparam \OUT_RX_DATA[6]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[6]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[6]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[6]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[6]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N3
maxii_lcell \Add9~1 (
// Equation(s):
// \Add9~1_combout  = \OUT_RX_DATA[4]~reg0_regout  $ (\OUT_RX_DATA[7]~reg0_regout  $ (\OUT_RX_DATA[5]~reg0_regout  $ (\OUT_RX_DATA[6]~reg0_regout )))

	.clk(gnd),
	.dataa(\OUT_RX_DATA[4]~reg0_regout ),
	.datab(\OUT_RX_DATA[7]~reg0_regout ),
	.datac(\OUT_RX_DATA[5]~reg0_regout ),
	.datad(\OUT_RX_DATA[6]~reg0_regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Add9~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Add9~1 .lut_mask = "6996";
defparam \Add9~1 .operation_mode = "normal";
defparam \Add9~1 .output_mode = "comb_only";
defparam \Add9~1 .register_cascade_mode = "off";
defparam \Add9~1 .sum_lutc_input = "datac";
defparam \Add9~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N8
maxii_lcell \Decoder0~4 (
// Equation(s):
// \Decoder0~4_combout  = ((!REG_BIT_INDEX[2] & (REG_BIT_INDEX[1] & !REG_BIT_INDEX[0])))

	.clk(gnd),
	.dataa(vcc),
	.datab(REG_BIT_INDEX[2]),
	.datac(REG_BIT_INDEX[1]),
	.datad(REG_BIT_INDEX[0]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~4_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~4 .lut_mask = "0030";
defparam \Decoder0~4 .operation_mode = "normal";
defparam \Decoder0~4 .output_mode = "comb_only";
defparam \Decoder0~4 .register_cascade_mode = "off";
defparam \Decoder0~4 .sum_lutc_input = "datac";
defparam \Decoder0~4 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N5
maxii_lcell \OUT_RX_DATA[2]~reg0 (
// Equation(s):
// \OUT_RX_DATA[2]~reg0_regout  = DFFEAS((\Decoder0~2_combout  & ((\Decoder0~4_combout  & ((\IN_RX_SERIAL~combout ))) # (!\Decoder0~4_combout  & (\OUT_RX_DATA[2]~reg0_regout )))) # (!\Decoder0~2_combout  & (\OUT_RX_DATA[2]~reg0_regout )), 
// GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\OUT_RX_DATA[2]~reg0_regout ),
	.datab(\IN_RX_SERIAL~combout ),
	.datac(\Decoder0~2_combout ),
	.datad(\Decoder0~4_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[2]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[2]~reg0 .lut_mask = "caaa";
defparam \OUT_RX_DATA[2]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[2]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[2]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[2]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[2]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N2
maxii_lcell \Decoder0~5 (
// Equation(s):
// \Decoder0~5_combout  = (REG_BIT_INDEX[0] & (((REG_BIT_INDEX[1] & !REG_BIT_INDEX[2]))))

	.clk(gnd),
	.dataa(REG_BIT_INDEX[0]),
	.datab(vcc),
	.datac(REG_BIT_INDEX[1]),
	.datad(REG_BIT_INDEX[2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~5_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~5 .lut_mask = "00a0";
defparam \Decoder0~5 .operation_mode = "normal";
defparam \Decoder0~5 .output_mode = "comb_only";
defparam \Decoder0~5 .register_cascade_mode = "off";
defparam \Decoder0~5 .sum_lutc_input = "datac";
defparam \Decoder0~5 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N1
maxii_lcell \OUT_RX_DATA[3]~reg0 (
// Equation(s):
// \OUT_RX_DATA[3]~reg0_regout  = DFFEAS((\Decoder0~2_combout  & ((\Decoder0~5_combout  & (\IN_RX_SERIAL~combout )) # (!\Decoder0~5_combout  & ((\OUT_RX_DATA[3]~reg0_regout ))))) # (!\Decoder0~2_combout  & (((\OUT_RX_DATA[3]~reg0_regout )))), 
// GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\IN_RX_SERIAL~combout ),
	.datab(\OUT_RX_DATA[3]~reg0_regout ),
	.datac(\Decoder0~2_combout ),
	.datad(\Decoder0~5_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[3]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[3]~reg0 .lut_mask = "accc";
defparam \OUT_RX_DATA[3]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[3]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[3]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[3]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[3]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N0
maxii_lcell \Decoder0~1 (
// Equation(s):
// \Decoder0~1_combout  = (!REG_BIT_INDEX[0] & (((!REG_BIT_INDEX[2]))))

	.clk(gnd),
	.dataa(REG_BIT_INDEX[0]),
	.datab(vcc),
	.datac(vcc),
	.datad(REG_BIT_INDEX[2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~1 .lut_mask = "0055";
defparam \Decoder0~1 .operation_mode = "normal";
defparam \Decoder0~1 .output_mode = "comb_only";
defparam \Decoder0~1 .register_cascade_mode = "off";
defparam \Decoder0~1 .sum_lutc_input = "datac";
defparam \Decoder0~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N7
maxii_lcell \OUT_RX_DATA[0]~reg0 (
// Equation(s):
// \OUT_RX_DATA[0]~reg0_regout  = DFFEAS((\Decoder0~1_combout  & ((\Decoder0~0_combout  & (\IN_RX_SERIAL~combout )) # (!\Decoder0~0_combout  & ((\OUT_RX_DATA[0]~reg0_regout ))))) # (!\Decoder0~1_combout  & (((\OUT_RX_DATA[0]~reg0_regout )))), 
// GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\IN_RX_SERIAL~combout ),
	.datab(\OUT_RX_DATA[0]~reg0_regout ),
	.datac(\Decoder0~1_combout ),
	.datad(\Decoder0~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[0]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[0]~reg0 .lut_mask = "accc";
defparam \OUT_RX_DATA[0]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[0]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[0]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[0]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[0]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N2
maxii_lcell \OUT_RX_DATA[1]~reg0 (
// Equation(s):
// \OUT_RX_DATA[1]~reg0_regout  = DFFEAS((REG_BIT_INDEX[2] & (\OUT_RX_DATA[1]~reg0_regout )) # (!REG_BIT_INDEX[2] & ((\Decoder0~3_combout  & ((\IN_RX_SERIAL~combout ))) # (!\Decoder0~3_combout  & (\OUT_RX_DATA[1]~reg0_regout )))), GLOBAL(\IN_CLOCK~combout ), 
// VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(REG_BIT_INDEX[2]),
	.datab(\OUT_RX_DATA[1]~reg0_regout ),
	.datac(\IN_RX_SERIAL~combout ),
	.datad(\Decoder0~3_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA[1]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA[1]~reg0 .lut_mask = "d8cc";
defparam \OUT_RX_DATA[1]~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA[1]~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA[1]~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA[1]~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA[1]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N2
maxii_lcell \Add9~0 (
// Equation(s):
// \Add9~0_combout  = \OUT_RX_DATA[2]~reg0_regout  $ (\OUT_RX_DATA[3]~reg0_regout  $ (\OUT_RX_DATA[0]~reg0_regout  $ (\OUT_RX_DATA[1]~reg0_regout )))

	.clk(gnd),
	.dataa(\OUT_RX_DATA[2]~reg0_regout ),
	.datab(\OUT_RX_DATA[3]~reg0_regout ),
	.datac(\OUT_RX_DATA[0]~reg0_regout ),
	.datad(\OUT_RX_DATA[1]~reg0_regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Add9~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Add9~0 .lut_mask = "6996";
defparam \Add9~0 .operation_mode = "normal";
defparam \Add9~0 .output_mode = "comb_only";
defparam \Add9~0 .register_cascade_mode = "off";
defparam \Add9~0 .sum_lutc_input = "datac";
defparam \Add9~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N3
maxii_lcell \Add9~2 (
// Equation(s):
// \Add9~2_combout  = (\IN_RX_SERIAL~combout  $ (\Add9~1_combout  $ (\Add9~0_combout )))

	.clk(gnd),
	.dataa(vcc),
	.datab(\IN_RX_SERIAL~combout ),
	.datac(\Add9~1_combout ),
	.datad(\Add9~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Add9~2_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Add9~2 .lut_mask = "c33c";
defparam \Add9~2 .operation_mode = "normal";
defparam \Add9~2 .output_mode = "comb_only";
defparam \Add9~2 .register_cascade_mode = "off";
defparam \Add9~2 .sum_lutc_input = "datac";
defparam \Add9~2 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N4
maxii_lcell \OUT_RX_ERROR~reg0 (
// Equation(s):
// \OUT_RX_ERROR~reg0_regout  = DFFEAS((\Selector1~0_combout ) # ((\Selector1~1_combout ) # ((\REG_STATE.STATE_RX_STOP_BIT~0_combout  & \Add9~2_combout ))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\Selector1~0_combout ),
	.datab(\REG_STATE.STATE_RX_STOP_BIT~0_combout ),
	.datac(\Selector1~1_combout ),
	.datad(\Add9~2_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_ERROR~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_ERROR~reg0 .lut_mask = "fefa";
defparam \OUT_RX_ERROR~reg0 .operation_mode = "normal";
defparam \OUT_RX_ERROR~reg0 .output_mode = "reg_only";
defparam \OUT_RX_ERROR~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_ERROR~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_ERROR~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N7
maxii_lcell \Selector0~0 (
// Equation(s):
// \Selector0~0_combout  = ((\OUT_RX_DATA_READY~reg0_regout  & ((\REG_STATE.STATE_WAIT~regout ) # (\REG_STATE.STATE_RX_STOP_BIT~regout ))))

	.clk(gnd),
	.dataa(vcc),
	.datab(\OUT_RX_DATA_READY~reg0_regout ),
	.datac(\REG_STATE.STATE_WAIT~regout ),
	.datad(\REG_STATE.STATE_RX_STOP_BIT~regout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Selector0~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Selector0~0 .lut_mask = "ccc0";
defparam \Selector0~0 .operation_mode = "normal";
defparam \Selector0~0 .output_mode = "comb_only";
defparam \Selector0~0 .register_cascade_mode = "off";
defparam \Selector0~0 .sum_lutc_input = "datac";
defparam \Selector0~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X2_Y3_N9
maxii_lcell \OUT_RX_DATA_READY~reg0 (
// Equation(s):
// \OUT_RX_DATA_READY~reg0_regout  = DFFEAS((\Selector0~0_combout ) # ((!\OUT_RX_ERROR~reg0_regout  & (\IN_RX_SERIAL~combout  & \Selector2~0_combout ))), GLOBAL(\IN_CLOCK~combout ), VCC, , , , , , )

	.clk(\IN_CLOCK~combout ),
	.dataa(\OUT_RX_ERROR~reg0_regout ),
	.datab(\Selector0~0_combout ),
	.datac(\IN_RX_SERIAL~combout ),
	.datad(\Selector2~0_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\OUT_RX_DATA_READY~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \OUT_RX_DATA_READY~reg0 .lut_mask = "dccc";
defparam \OUT_RX_DATA_READY~reg0 .operation_mode = "normal";
defparam \OUT_RX_DATA_READY~reg0 .output_mode = "reg_only";
defparam \OUT_RX_DATA_READY~reg0 .register_cascade_mode = "off";
defparam \OUT_RX_DATA_READY~reg0 .sum_lutc_input = "datac";
defparam \OUT_RX_DATA_READY~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_4,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA_READY~I (
	.datain(\OUT_RX_DATA_READY~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA_READY));
// synopsys translate_off
defparam \OUT_RX_DATA_READY~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[0]~I (
	.datain(\OUT_RX_DATA[0]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[0]));
// synopsys translate_off
defparam \OUT_RX_DATA[0]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[1]~I (
	.datain(\OUT_RX_DATA[1]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[1]));
// synopsys translate_off
defparam \OUT_RX_DATA[1]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_12,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[2]~I (
	.datain(\OUT_RX_DATA[2]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[2]));
// synopsys translate_off
defparam \OUT_RX_DATA[2]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_3,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[3]~I (
	.datain(\OUT_RX_DATA[3]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[3]));
// synopsys translate_off
defparam \OUT_RX_DATA[3]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_68,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[4]~I (
	.datain(\OUT_RX_DATA[4]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[4]));
// synopsys translate_off
defparam \OUT_RX_DATA[4]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_69,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[5]~I (
	.datain(\OUT_RX_DATA[5]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[5]));
// synopsys translate_off
defparam \OUT_RX_DATA[5]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_67,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[6]~I (
	.datain(\OUT_RX_DATA[6]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[6]));
// synopsys translate_off
defparam \OUT_RX_DATA[6]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_66,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_DATA[7]~I (
	.datain(\OUT_RX_DATA[7]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_DATA[7]));
// synopsys translate_off
defparam \OUT_RX_DATA[7]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_2,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \OUT_RX_ERROR~I (
	.datain(\OUT_RX_ERROR~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(OUT_RX_ERROR));
// synopsys translate_off
defparam \OUT_RX_ERROR~I .operation_mode = "output";
// synopsys translate_on

endmodule
